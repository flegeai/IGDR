.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Parser 3"
.TH Parser 3 "2014-12-04" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
package Parser \- Parse input files for FEELnc datastructures
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&        use Parser;
\&        my $refhgtf      =      Parser::parseGTF(\*(Aqinfile.gtf\*(Aq);
\&        my $refhgene =  Parser::parseGTFgnlight(\*(Aqinfile.gtf\*(Aq);
\&        my $refhcpat =  Parser::parseCPAT(\*(Aqinfile.cpat\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides different function to parse input files (especially gtf)
and return specific data structure: 3 data structures (dsc) are possible:
	* tx-based		: transcript-based with exon as arrayfeat 
	* chrom-based	: chr-based (see split variable)
	* gene-based	: gene-based with transcript and exon levels (possibly with only gene ranges (see parseGTFgnlight))
		\- full
		\- light
.ie n .SS "parseGTF Title		:	parseGTF Function	:	parse a .GTF file Example		:	$refmrna	= Parser::parseGTF($infilegtf); Returns		: 	A Feelnc tx-based \s-1DSC \s0	Args		: \- infile	: file \- a gtf file (mandatory) \- levels	: string \- specify the the level(s) of annotation to be parsed separated by "","" (e.g exon,CDS) \- split		: boolean \- 0 or 1 if we want to return a chrom-based dsc \- refhfilter: hashref \- with key value to be extracted e.g 'transcript_id=ENSCAFT00000017943,ENSCAFT00000017911' \- verbosity	: numeric \- level of verbosity"
.el .SS "parseGTF Title		:	parseGTF Function	:	parse a .GTF file Example		:	\f(CW$refmrna\fP	= Parser::parseGTF($infilegtf); Returns		: 	A Feelnc tx-based \s-1DSC \s0	Args		: \- infile	: file \- a gtf file (mandatory) \- levels	: string \- specify the the level(s) of annotation to be parsed separated by ``,'' (e.g exon,CDS) \- split		: boolean \- 0 or 1 if we want to return a chrom-based dsc \- refhfilter: hashref \- with key value to be extracted e.g 'transcript_id=ENSCAFT00000017943,ENSCAFT00000017911' \- verbosity	: numeric \- level of verbosity"
.IX Subsection "parseGTF Title : parseGTF Function : parse a .GTF file Example : $refmrna = Parser::parseGTF($infilegtf); Returns : A Feelnc tx-based DSC Args : - infile : file - a gtf file (mandatory) - levels : string - specify the the level(s) of annotation to be parsed separated by , (e.g exon,CDS) - split : boolean - 0 or 1 if we want to return a chrom-based dsc - refhfilter: hashref - with key value to be extracted e.g 'transcript_id=ENSCAFT00000017943,ENSCAFT00000017911' - verbosity : numeric - level of verbosity"
.ie n .SS "parseAttributes Title		:	parseAttributes Function	:	parse attributes of a gtf file (i.e after 9th column) Returns		: 	A hashref with key/val corresponding to the attributes Example		:	$href	= Parser::parseAttributes('gene_id ""\s-1RLOC_00032935""\s0; transcript_id ""CFRNASEQ_IGNC_Spliced_00193147""; transcript_biotype ""lncRNA"";'); Args		: \- string	: string \- corresponding to attrributes (mandatory) \- refhfilter: hashref \- with key value to be extracted e.g 'transcript_id=ENSCAFT00000017943,ENSCAFT00000017911' \- verbosity	: numeric \- level of verbosity Note		:  transcript_biotype and gene_biotype (not transcript/gene_type) are the official nomenclature for 'type' of transcript (lincRNA, pseudogene...)"
.el .SS "parseAttributes Title		:	parseAttributes Function	:	parse attributes of a gtf file (i.e after 9th column) Returns		: 	A hashref with key/val corresponding to the attributes Example		:	\f(CW$href\fP	= Parser::parseAttributes('gene_id ``\s-1RLOC_00032935''\s0; transcript_id ``CFRNASEQ_IGNC_Spliced_00193147''; transcript_biotype ``lncRNA'';'); Args		: \- string	: string \- corresponding to attrributes (mandatory) \- refhfilter: hashref \- with key value to be extracted e.g 'transcript_id=ENSCAFT00000017943,ENSCAFT00000017911' \- verbosity	: numeric \- level of verbosity Note		:  transcript_biotype and gene_biotype (not transcript/gene_type) are the official nomenclature for 'type' of transcript (lincRNA, pseudogene...)"
.IX Subsection "parseAttributes Title : parseAttributes Function : parse attributes of a gtf file (i.e after 9th column) Returns : A hashref with key/val corresponding to the attributes Example : $href = Parser::parseAttributes('gene_id RLOC_00032935; transcript_id CFRNASEQ_IGNC_Spliced_00193147; transcript_biotype lncRNA;'); Args : - string : string - corresponding to attrributes (mandatory) - refhfilter: hashref - with key value to be extracted e.g 'transcript_id=ENSCAFT00000017943,ENSCAFT00000017911' - verbosity : numeric - level of verbosity Note : transcript_biotype and gene_biotype (not transcript/gene_type) are the official nomenclature for 'type' of transcript (lincRNA, pseudogene...)"
.ie n .SS "filterFields Title		:	filterFields Function	:	parse attributes of a gtf file (i.e after 9th column) Returns		: 	A boolean : 0 if we filter out the transcript and 1 otherwise Example		:	$bool	= Parser::filterFields(\estrand => '\-', $h_transcript{$transcript} Args		: \- refhfilter	: hashref \- with key value to be extracted e.g 'transcript_id=ENSCAFT00000017943,ENSCAFT00000017911' \- refhanonym	: hasref \- a tx-based or gene-based refh Note		:  see also parseAttributes for attributes Note		:  to check if to be deprecated"
.el .SS "filterFields Title		:	filterFields Function	:	parse attributes of a gtf file (i.e after 9th column) Returns		: 	A boolean : 0 if we filter out the transcript and 1 otherwise Example		:	\f(CW$bool\fP	= Parser::filterFields(\estrand => '\-', \f(CW$h_transcript\fP{$transcript} Args		: \- refhfilter	: hashref \- with key value to be extracted e.g 'transcript_id=ENSCAFT00000017943,ENSCAFT00000017911' \- refhanonym	: hasref \- a tx-based or gene-based refh Note		:  see also parseAttributes for attributes Note		:  to check if to be deprecated"
.IX Subsection "filterFields Title : filterFields Function : parse attributes of a gtf file (i.e after 9th column) Returns : A boolean : 0 if we filter out the transcript and 1 otherwise Example : $bool = Parser::filterFields(strand => '-', $h_transcript{$transcript} Args : - refhfilter : hashref - with key value to be extracted e.g 'transcript_id=ENSCAFT00000017943,ENSCAFT00000017911' - refhanonym : hasref - a tx-based or gene-based refh Note : see also parseAttributes for attributes Note : to check if to be deprecated"
.ie n .SS "correctSourceBiotype Title		:	correctSourceBiotype Function	:	Correct the transcript_biotype if it is in 2nd fields of the gtf file (such as in Ensembl) Returns		: 	a string to be added to the attribtues or undef otherwise : my $string "" transcript_biotype \e""$source\e"";""; Example		:	my $correctbiotype = correctSourceBiotype($source, $i, $verbosity); Args		: \- source	: string \- corresponding to 2nd fields of the gtf \- i			: numeric \- $i is just a counter for printing (efault is to print 5 occurences) \- verbosity	: numeric \- level of verbosity Note		:  checks whether the 2nd columns contains known biotype extracted from Ensembl Homo_sapiens.GRCh37.70.gtf file (see list in the code)"
.el .SS "correctSourceBiotype Title		:	correctSourceBiotype Function	:	Correct the transcript_biotype if it is in 2nd fields of the gtf file (such as in Ensembl) Returns		: 	a string to be added to the attribtues or undef otherwise : my \f(CW$string\fP `` transcript_biotype \e''$source\e``;''; Example		:	my \f(CW$correctbiotype\fP = correctSourceBiotype($source, \f(CW$i\fP, \f(CW$verbosity\fP); Args		: \- source	: string \- corresponding to 2nd fields of the gtf \- i			: numeric \- \f(CW$i\fP is just a counter for printing (efault is to print 5 occurences) \- verbosity	: numeric \- level of verbosity Note		:  checks whether the 2nd columns contains known biotype extracted from Ensembl Homo_sapiens.GRCh37.70.gtf file (see list in the code)"
.IX Subsection "correctSourceBiotype Title : correctSourceBiotype Function : Correct the transcript_biotype if it is in 2nd fields of the gtf file (such as in Ensembl) Returns : a string to be added to the attribtues or undef otherwise : my $string transcript_biotype $source;; Example : my $correctbiotype = correctSourceBiotype($source, $i, $verbosity); Args : - source : string - corresponding to 2nd fields of the gtf - i : numeric - $i is just a counter for printing (efault is to print 5 occurences) - verbosity : numeric - level of verbosity Note : checks whether the 2nd columns contains known biotype extracted from Ensembl Homo_sapiens.GRCh37.70.gtf file (see list in the code)"
.ie n .SS "splitbyChr Title		:	splitbyChr Function	:	split a tx/gene\-based feelnc dsc into a chrom-based (seqname) feelnc dsc to speed up overlap computation Returns		: 	a hashref chrom-based feelnc dsc Example		:	my $refhchr = splitbyChr($refh, $verbosity); Args		: \- hreftx	: href \- tx/gene\-based feelnc dsc \- verbosity	: numeric \- level of verbosity"
.el .SS "splitbyChr Title		:	splitbyChr Function	:	split a tx/gene\-based feelnc dsc into a chrom-based (seqname) feelnc dsc to speed up overlap computation Returns		: 	a hashref chrom-based feelnc dsc Example		:	my \f(CW$refhchr\fP = splitbyChr($refh, \f(CW$verbosity\fP); Args		: \- hreftx	: href \- tx/gene\-based feelnc dsc \- verbosity	: numeric \- level of verbosity"
.IX Subsection "splitbyChr Title : splitbyChr Function : split a tx/gene-based feelnc dsc into a chrom-based (seqname) feelnc dsc to speed up overlap computation Returns : a hashref chrom-based feelnc dsc Example : my $refhchr = splitbyChr($refh, $verbosity); Args : - hreftx : href - tx/gene-based feelnc dsc - verbosity : numeric - level of verbosity"
.ie n .SS "parseGTFgene Title		:	parseGTFgene Function	:	parse a .GTF file into gene-based feelnc dsc Example		:	$refmrna	= Parser::parseGTF($infilegtf); Returns		: 	A Feelnc tx-based \s-1DSC \s0	Args		: \- infile	: file \- a gtf file (mandatory) \- levels	: string \- specify the the level(s) of annotation to be parsed separated by "","" (e.g exon,CDS) \- split		: boolean \- 0 or 1 if we want to return a chrom-based dsc \- refhfilter: hashref \- with key value to be extracted e.g 'transcript_id=ENSCAFT00000017943,ENSCAFT00000017911' \- verbosity	: numeric \- level of verbosity"
.el .SS "parseGTFgene Title		:	parseGTFgene Function	:	parse a .GTF file into gene-based feelnc dsc Example		:	\f(CW$refmrna\fP	= Parser::parseGTF($infilegtf); Returns		: 	A Feelnc tx-based \s-1DSC \s0	Args		: \- infile	: file \- a gtf file (mandatory) \- levels	: string \- specify the the level(s) of annotation to be parsed separated by ``,'' (e.g exon,CDS) \- split		: boolean \- 0 or 1 if we want to return a chrom-based dsc \- refhfilter: hashref \- with key value to be extracted e.g 'transcript_id=ENSCAFT00000017943,ENSCAFT00000017911' \- verbosity	: numeric \- level of verbosity"
.IX Subsection "parseGTFgene Title : parseGTFgene Function : parse a .GTF file into gene-based feelnc dsc Example : $refmrna = Parser::parseGTF($infilegtf); Returns : A Feelnc tx-based DSC Args : - infile : file - a gtf file (mandatory) - levels : string - specify the the level(s) of annotation to be parsed separated by , (e.g exon,CDS) - split : boolean - 0 or 1 if we want to return a chrom-based dsc - refhfilter: hashref - with key value to be extracted e.g 'transcript_id=ENSCAFT00000017943,ENSCAFT00000017911' - verbosity : numeric - level of verbosity"
.ie n .SS "parsedoubleGTF Title		:	parsedoubleGTF Function	:	parse a  double .GTF file i.e when 2 gtf line are overlapping for instance Example		:	$refmrna	= Parser:::parsedoubleGTF($infileB, 'exon',  undef, undef, $verbosity); Returns		: 	A Feelnc tx-based \s-1DSC \s0	Args		: \- infile	: file \- a gtf file (mandatory) \- levels	: string \- specify the the level(s) of annotation to be parsed separated by "","" (e.g exon,CDS) \- split		: boolean \- 0 or 1 if we want to return a chrom-based dsc \- refhfilter: hashref \- with key value to be extracted e.g 'transcript_id=ENSCAFT00000017943,ENSCAFT00000017911' \- verbosity	: numeric \- level of verbosity Note		:  only used in addAttribfromIntersect.pl (to be deprecated?)"
.el .SS "parsedoubleGTF Title		:	parsedoubleGTF Function	:	parse a  double .GTF file i.e when 2 gtf line are overlapping for instance Example		:	\f(CW$refmrna\fP	= Parser:::parsedoubleGTF($infileB, 'exon',  undef, undef, \f(CW$verbosity\fP); Returns		: 	A Feelnc tx-based \s-1DSC \s0	Args		: \- infile	: file \- a gtf file (mandatory) \- levels	: string \- specify the the level(s) of annotation to be parsed separated by ``,'' (e.g exon,CDS) \- split		: boolean \- 0 or 1 if we want to return a chrom-based dsc \- refhfilter: hashref \- with key value to be extracted e.g 'transcript_id=ENSCAFT00000017943,ENSCAFT00000017911' \- verbosity	: numeric \- level of verbosity Note		:  only used in addAttribfromIntersect.pl (to be deprecated?)"
.IX Subsection "parsedoubleGTF Title : parsedoubleGTF Function : parse a double .GTF file i.e when 2 gtf line are overlapping for instance Example : $refmrna = Parser:::parsedoubleGTF($infileB, 'exon', undef, undef, $verbosity); Returns : A Feelnc tx-based DSC Args : - infile : file - a gtf file (mandatory) - levels : string - specify the the level(s) of annotation to be parsed separated by , (e.g exon,CDS) - split : boolean - 0 or 1 if we want to return a chrom-based dsc - refhfilter: hashref - with key value to be extracted e.g 'transcript_id=ENSCAFT00000017943,ENSCAFT00000017911' - verbosity : numeric - level of verbosity Note : only used in addAttribfromIntersect.pl (to be deprecated?)"
.ie n .SS "parseBed Title		:	parseBed Function	:	parse a .BED file Example		:	$refmrna	= Parser::parseBed($infilegtf); Returns		: 	A Feelnc tx-based \s-1DSC \s0	Args		: \- infile				: file \- a gtf file (mandatory) \- transcript_biotype	: string \- since it is not present in .BED it could be added (default '\s-1NA\s0') \- verbosity	: numeric \- level of verbosity Note		:  to be \s-1TESTED\s0 and for conformity with parseGTF"
.el .SS "parseBed Title		:	parseBed Function	:	parse a .BED file Example		:	\f(CW$refmrna\fP	= Parser::parseBed($infilegtf); Returns		: 	A Feelnc tx-based \s-1DSC \s0	Args		: \- infile				: file \- a gtf file (mandatory) \- transcript_biotype	: string \- since it is not present in .BED it could be added (default '\s-1NA\s0') \- verbosity	: numeric \- level of verbosity Note		:  to be \s-1TESTED\s0 and for conformity with parseGTF"
.IX Subsection "parseBed Title : parseBed Function : parse a .BED file Example : $refmrna = Parser::parseBed($infilegtf); Returns : A Feelnc tx-based DSC Args : - infile : file - a gtf file (mandatory) - transcript_biotype : string - since it is not present in .BED it could be added (default 'NA') - verbosity : numeric - level of verbosity Note : to be TESTED and for conformity with parseGTF"
.ie n .SS "parseGTFgnlight Title		:	parseGTFgnlight Function	:	parse a .GTF file into gene-based feelnc dsc with only gene ranges (wihout transcript and exon levels) Example		:	$refgene	= Parser::parseGTF($infilegtf); Returns		: 	A Feelnc gene-based \s-1DSC \s0	Args		: \- infile	: file \- a gtf file (mandatory) \- split		: boolean \- 0 or 1 if we want to return a chrom-based dsc \- verbosity	: numeric \- level of verbosity"
.el .SS "parseGTFgnlight Title		:	parseGTFgnlight Function	:	parse a .GTF file into gene-based feelnc dsc with only gene ranges (wihout transcript and exon levels) Example		:	\f(CW$refgene\fP	= Parser::parseGTF($infilegtf); Returns		: 	A Feelnc gene-based \s-1DSC \s0	Args		: \- infile	: file \- a gtf file (mandatory) \- split		: boolean \- 0 or 1 if we want to return a chrom-based dsc \- verbosity	: numeric \- level of verbosity"
.IX Subsection "parseGTFgnlight Title : parseGTFgnlight Function : parse a .GTF file into gene-based feelnc dsc with only gene ranges (wihout transcript and exon levels) Example : $refgene = Parser::parseGTF($infilegtf); Returns : A Feelnc gene-based DSC Args : - infile : file - a gtf file (mandatory) - split : boolean - 0 or 1 if we want to return a chrom-based dsc - verbosity : numeric - level of verbosity"
.ie n .SS "GTF2GTFgnlight Title		:	GTF2GTFgnlight Function	:	convert a full gene-based feelnc dsc into light gene-based feelnc dsc with only gene ranges (wihout transcript and exon levels) Example		:	GTF2GTFgnlight ($h, $split, $verbosity); Returns		: 	A Feelnc light gene-based \s-1DSC \s0	Args		: \- href		: ref \- hashref of full gene-based feelnc dsc \- split		: boolean \- 0 or 1 if we want to return a chrom-based dsc \- verbosity	: numeric \- level of verbosity Note		: see FEELnc_codpot.pl"
.el .SS "GTF2GTFgnlight Title		:	GTF2GTFgnlight Function	:	convert a full gene-based feelnc dsc into light gene-based feelnc dsc with only gene ranges (wihout transcript and exon levels) Example		:	GTF2GTFgnlight ($h, \f(CW$split\fP, \f(CW$verbosity\fP); Returns		: 	A Feelnc light gene-based \s-1DSC \s0	Args		: \- href		: ref \- hashref of full gene-based feelnc dsc \- split		: boolean \- 0 or 1 if we want to return a chrom-based dsc \- verbosity	: numeric \- level of verbosity Note		: see FEELnc_codpot.pl"
.IX Subsection "GTF2GTFgnlight Title : GTF2GTFgnlight Function : convert a full gene-based feelnc dsc into light gene-based feelnc dsc with only gene ranges (wihout transcript and exon levels) Example : GTF2GTFgnlight ($h, $split, $verbosity); Returns : A Feelnc light gene-based DSC Args : - href : ref - hashref of full gene-based feelnc dsc - split : boolean - 0 or 1 if we want to return a chrom-based dsc - verbosity : numeric - level of verbosity Note : see FEELnc_codpot.pl"
.ie n .SS "parseCPAT Title		:	parseCPAT Function	:	parse a \s-1CPAT\s0 output file Example		:	Parser::parseCPAT($featurefile, $verbosity); Returns		: 	a tx-based \s-1CPAT\s0 hashfref Args		: \- infile	: file \- a \s-1CPAT\s0 file (mandatory) \- verbosity	: numeric \- level of verbosity Note		: see FEELnc_codpot.pl"
.el .SS "parseCPAT Title		:	parseCPAT Function	:	parse a \s-1CPAT\s0 output file Example		:	Parser::parseCPAT($featurefile, \f(CW$verbosity\fP); Returns		: 	a tx-based \s-1CPAT\s0 hashfref Args		: \- infile	: file \- a \s-1CPAT\s0 file (mandatory) \- verbosity	: numeric \- level of verbosity Note		: see FEELnc_codpot.pl"
.IX Subsection "parseCPAT Title : parseCPAT Function : parse a CPAT output file Example : Parser::parseCPAT($featurefile, $verbosity); Returns : a tx-based CPAT hashfref Args : - infile : file - a CPAT file (mandatory) - verbosity : numeric - level of verbosity Note : see FEELnc_codpot.pl"
